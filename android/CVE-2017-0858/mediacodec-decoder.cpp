#include <binder/ProcessState.h>
#include <media/stagefright/MediaBufferGroup.h>
#include <media/stagefright/MediaDefs.h>
#include <media/stagefright/MetaData.h>
#include <media/stagefright/SimpleDecodingSource.h>
#include <media/stagefright/FileSource.h>
#include <media/stagefright/MediaSource.h>
#include <media/stagefright/MediaCodecList.h>

using namespace android;

class MiniSource : public MediaSource {
public:
  MiniSource(const sp<FileSource> &fileSource);
  virtual status_t start(MetaData *params = NULL);
  virtual status_t stop();
  virtual sp<MetaData> getFormat();
  virtual status_t read(MediaBuffer **buffer, const ReadOptions *options = NULL);

protected:
  virtual ~MiniSource();

private:
  sp<FileSource> mFileSource;
  bool mStarted;
  MediaBufferGroup *mGroup;
  int64_t mLength;
  off64_t mCurrentPos;
};

MiniSource::MiniSource(const sp<FileSource> &fileSource)
  :mFileSource(fileSource),
   mStarted(false),
   mGroup(NULL),
   mLength(0),
   mCurrentPos(0)
{
}

MiniSource::~MiniSource()
{
  if (mStarted) {
    stop();
  }
}

status_t MiniSource::start(MetaData *) {
    CHECK(!mStarted);

    mFileSource->getSize(&mLength);

    mGroup = new MediaBufferGroup;

    mGroup->add_buffer(new MediaBuffer(mLength));

    mStarted = true;

    return OK;
}

status_t MiniSource::stop() {
    CHECK(mStarted);

    delete mGroup;
    mGroup = NULL;

    mStarted = false;

    return OK;
}

sp<MetaData> MiniSource::getFormat()
{
  sp<MetaData> meta = new MetaData;
  meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
  meta->setInt32(kKeyWidth, 176);
  meta->setInt32(kKeyHeight, 144);
  return meta;
}

status_t MiniSource::read(
  MediaBuffer **out, const ReadOptions *)
{
  *out = NULL;

  MediaBuffer *buffer;
  status_t err = mGroup->acquire_buffer(&buffer);
  if (err != OK) {
    return err;
  }

  CHECK(mLength <= buffer->size());

  ssize_t n = mFileSource->readAt(mCurrentPos, (uint8_t *)buffer->data(), mLength);
  if (n != mLength) {
      buffer->release();
      buffer = NULL;

      return ERROR_END_OF_STREAM;
  }

  buffer->set_range(0, mLength);

  buffer->meta_data()->setInt64(kKeyTime, 0);

  mCurrentPos += mLength;

  *out = buffer;

  return OK;
}

void decode(const char *path) {
    sp<FileSource> fileSource = new FileSource(path);
    if (fileSource == NULL) {
        printf("fileSource is NULL\n");
        return;
    }

    sp<IMediaSource> mediaSource = new MiniSource(fileSource);

    sp<MediaSource> decoder = SimpleDecodingSource::Create(mediaSource, MediaCodecList::kPreferSoftwareCodecs, NULL);
    if (decoder == NULL) {
        printf("decoder is NULL\n");
        return;
    }

    status_t err = decoder->start();
    if (err != (status_t) OK) {
        printf("decoder start failed\n");
        return;
    }

    long numFrames = 0;
    MediaBuffer *buffer;
    for (;;) {
        status_t err = decoder->read(&buffer);

        if (err != OK) {
            if (err == INFO_FORMAT_CHANGED) {
                printf("format changed.\n");
                continue;
            }
            break;
        }

        if (buffer->range_length() > 0) {
                printf(".");
                fflush(stdout);
        }

        buffer->release();
        buffer = NULL;

        ++numFrames;
        if (numFrames == 1) {
            break;
        }
    }

    err = decoder->stop();
    if (err != (status_t) OK) {
        printf("decoder stop failed\n");
        return;
    }

    printf("$\n");
}

int main(int argc, char **argv)
{
    if (argc != 2) {
        return -1;
    }

    android::ProcessState::self()->startThreadPool();

    decode(argv[1]);
}
